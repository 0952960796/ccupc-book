# 基礎動態規劃

> 作者: **D1stance**

在枚舉法中，我們說暴力是一個可以保證正確性的解法，只要給他足夠的時間，幾乎可以解決世界上所有的問題。但枚舉法的問題是所花費的時間太多了，我們先來看看怎麼用暴力搜尋法解決問題，再看看我們如何從中找到可以優化的地方，最終得出動態規劃的概念。

>#### 例題
>假設你正在爬樓梯，
>需要走 \\(n\\) 階才能走到樓頂，
>因為腳長跟安全問題每次最多跨 \\(1\\) 階或 \\(2\\) 階，
>請問走到樓頂有幾種方法?
>
> \\(1 \le n \le 50\\)


以 \\(n = 3\\) 為例，
我們有以下幾種走法：
- 1, 1, 1
- 1, 2
- 2, 1

![alt text](stair1.png)

如上圖所示，
我們走到第三階有兩種可能：
- 從第二階走一階上去
- 從第一階走兩階上去

那走到第二階又有兩種可能：
- 從第一階走一階上去
- 從零階走兩階上去

因此，我們其實可以發現，
走到第 \\(n\\) 階的方法數量等於走到第 \\(n-1\\) 階的方法數量加上走到第 \\(n-2\\) 階的方法數量，
也就是說我們可以用以下的遞迴式來表示：
\\[
f(n) = f(n-1) + f(n-2)
\\]

以程式碼來表示就是：
```cpp
long long f(int i)
{
    if(i == 0)
        return 1; // 找到一個從第 0 階開始的合法走法
    if(i < 0)
        return 0; // 非法走法
    return f(i - 1) + f(i - 2);
}
```

因為對於每個 \\(i\\)，
我們都會計算出 \\(f(i-1)\\) 和 \\(f(i-2)\\) 的值，
所以時間複雜度是 \\(\mathcal{O}(2^n)\\)，
現在的的效率是很差的，無法通過 \\(n = 50\\) 的測試，
因此我們需要想辦法優化。

<center>
<img src="stair2.png" alt="stair2" style="width: 40rem;"/>
</center>

從上圖的遞迴過程中可以發現，有很多問題在遞迴過程中被重複計算了，
還記得我們在遞迴那章節中提到可以用額外的空間來記錄已經計算過的值嗎？

我們可以用一個陣列來記錄每個 \\(f(i)\\) 的值，
這樣就可以避免重複計算，因為只要求出 \\(1 \sim n \\) 的值，
每一格只要詢問前兩格的值就可以了，所以時間複雜度就變成 \\(\mathcal{O}(n)\\)。

這個技巧我們稱為記憶化搜尋 (Memoization)，
也就是在遞迴的過程中記錄已經計算過的值，
這樣就可以避免重複計算，提升效率。

```cpp
vector<long long> dp(51, -1); // 初始化 dp 陣列
long long f(int i)
{
    if(i == 0)
        return 1; // 找到一個從第 0 階開始的合法
    if(i < 0)
        return 0; // 非法走法
    if(dp[i] != -1) // 如果已經計算過了，就直接返回
        return dp[i];
    return dp[i] = f(i - 1) + f(i - 2);
    // 這個寫法是先將 f(i - 1) + f(i - 2) 的值存到 dp[i] 中，
    // 然後再 return dp[i] 的值。
}
```

那麼，在記憶化搜索的過程中，我們發現答案會從 \\(f(1), f(2), \ldots, f(n)\\) 一直被計算到 \\(f(n)\\)，
這樣的過程其實可以用迴圈來實現，由小到大計算每個值，
這樣就不需要遞迴了，時間複雜度還是 \\(\mathcal{O}(n)\\)。

```cpp
vector<long long> dp(51, -1); // 初始化 dp 陣列
dp[0] = 1; // 第 0 階只有一種走法
for(int i = 1; i <= n; ++i)
{
    if(i == 1)
        dp[i] = 1; // 第 1 階只有一種走法
    else
        dp[i] = dp[i - 1] + dp[i - 2]; // 第 i 階的走法等於第 i-1 階和第 i-2 階的走法之和
}
```

這裡筆者個人不喜歡額外做判斷，容易出錯，
因為轉移方程式已經包含了所有的情況，
所以比較喜歡所有的答案都是透過轉移方程式計算出來的。

因為 \\(f(i) = f(i-1) + f(i-2)\\) 在 \\(i = 1\\) 時會因為 \\(f(i - 2)\\) 的部分導致陣列索引值有負號，容易造成問題，
筆者喜歡將答案往右偏移兩格，變成 \\(f(i + 2) = f(i + 1) + f(i)\\)，
這樣就不會有負號的問題了，
因此我們可以將陣列的大小設為 \\(n + 3\\)，
這樣就可以避免負號的問題了。

```cpp
vector<long long> dp(n + 3, -1); // 初始化 dp 陣列
dp[0 + 2] = 1; // 第 0 階只有一種走法
for(int i = 1; i <= n; ++i)
    dp[i + 2] = dp[i + 1] + dp[i]; // 第 i 階的走法等於第 i-1 階和第 i-2 階的走法之和
```

用空間換取時間的做法，我們稱為動態規劃 (Dynamic Programming)，
第一種用遞迴從大問題開始拆解，慢慢計算出小問題的值，稱為自頂向下 (Top-Down) 的動態規劃，
第二種用迴圈從小問題開始計算，慢慢累積到大問題的值，稱為自底向上 (Bottom-Up) 的動態規劃，
這兩種方法都可以解決問題，但自底向上的方法通常更有效率，
因為它不需要額外的遞迴呼叫開銷，但是以初學者而言，可能會對遞迴的思維方式更容易理解。

## 動態規劃的概念

我們在求解問題的時候，從問題的答案往回推有時是會比較容易的，當我們發現將大問題拆解成小問題的時候，如果有很多問題是會被重複詢問的，那我們就可以透過動態規劃來解決這個問題。

動態規劃求解問題有以下三個特性：
1. **最優子結構 (Optimal Substructure)**：問題的最優解可以由其子問題的最優解組成。
2. **重疊子問題 (Overlapping Subproblems)**：問題可以被拆解成多個子問題，這些子問題會被重複計算。
3. **無後效性 (No Aftereffect)**：子問題答案算好後，後續的計算不會影響到已經計算好的子問題答案。

因為這幾個特性，我們才可以透過空間換取時間，來大幅度減少計算的成本。

在計算時間複雜度的時候，我們通常會考慮以下幾個方面：
- **狀態數量**：我們需要考慮有多少種不同的子問題需要計算。
- **狀態轉移方程式**：我們需要考慮每個子問題的計算方式，通常是透過遞迴或迴圈來實現。
- **狀態轉移的時間複雜度**：我們需要考慮每個子問題的計算時間，通常是常數時間或線性時間。

因為動態規劃使用了額外的空間來記錄已經計算過的值，所以除了時間複雜度以外也要考慮空間複雜度，通常是 \\(\mathcal{O}(n)\\) 或 \\(\mathcal{O}(n^2)\\)，因為 C++ 陣列大約可接受最高 \\(10^7\\) 的大小，所以其實比起時間複雜度來說，空間複雜度的限制是比較嚴格的。

## 打家劫舍

>現在有 \\(n\\) 間房子，第 \\(i\\) 間房子裡面有 \\(c_i\\) 元的現金，
>現在有一個小偷要進去偷錢，
>當某個房子被偷時，相鄰的兩間房子的主人會提高警覺，
>如果小偷進去了相鄰的房子就會被抓到，
>請問小偷在不被抓的情況下，能偷到最多多少錢?
>
> \\(1 \le n \le 10^5\\)
> \\(1 \le c_i \le 10^9\\)

\\(c = [2, 7, 9, 3, 1]\\)

選擇偷第 \\(1, 3, 5\\) 間房子是最好的，
可以得到 \\(2 + 9 + 1 = 12\\) 的錢。

我們要先確立好問題是什麼，這問題其實跟子集合枚舉有點像，
只是加上了相鄰數字不能同時被選取的限制，
因此我們可以用遞迴的方式來解決這個問題。

一開始你可能會想要這樣設計遞迴式，

\\(f(\text{第一間房子偷與不偷}, \text{第二間房子偷與不偷}, \ldots, \text{第 n 間房子偷與不偷})\\) 代表對於這 \\(n\\) 間房子，
偷與不偷的所有組合下能獲得的最大金額，
首先這個遞迴有一個明顯的問題，就是參數數量是不確定的，
這樣沒有一個簡單的方法可以轉程式碼跟設計轉移方程式。

所以我們轉個方向想，第 \\(i\\) 間房子能否偷取，只跟左右兩間房子有關，
如果我們從後面開始考慮，
- 如果第 \\(i\\) 間房子偷了，那麼答案會從第 \\(i-1\\) 間房子不偷的答案加上第 \\(i\\) 間房子的錢，
- 如果第 \\(i\\) 間房子不偷，那麼答案會從第 \\(i-1\\) 間房子偷或不偷的答案中取
最大的值。

因此我們可以設計出以下的轉移方程式：

\\(f(i, s = 0) = \max(f(i - 1, 0), f(i - 1, 1))\\) <br>
\\(f(i, s = 1) = f(i - 1, 0) + c_i\\)

這裡的 \\(s\\) 代表第 \\(i\\) 間房子是否偷取，
- 如果 \\(s = 1\\)，代表第 \\(i\\) 間房子被偷了，
- 如果 \\(s = 0\\)，代表第 \\(i\\) 間房子沒有被偷。

我們可以用一個陣列來記錄每個房子被偷或不被偷的最大金額，
因此總共有 \\(2n\\) 種狀態，每個狀態最多只要知道兩個狀態的值，而且可以馬上得知，所以時間複雜度為 \\(\mathcal{O}(n)\\)，
空間複雜度為 \\(\mathcal{O}(n)\\)。

### 狀態優化

定義新的子問題 \\(g(i) = \max(f(i, 0), f(i, 1))\\)，
也就是第 \\(i\\) 間房子偷或不偷的最大金額，
那麼我們可以將轉移方程式簡化為：

原本關係式中 \\(f(i - 1, 0) = \max(f(i - 2, 0), f(i - 2, 1))\\)，
其實就是 \\(g(i - 1)\\)，

那原本關係式中 \\(f(i - 1, 1) = f(i - 2, 0) + c_i\\)，
其實就是 \\(g(i - 2) + c_i\\)，也就是說我們可以將轉移方程式簡化為：
\\[
    g(i) = \max(g(i - 1), g(i - 2) + c_i)
\\]

這樣可以把狀態減少一半，用白話文來理解的話就是，
- 如果第 \\(i\\) 間房子偷了，那麼答案會從第 \\(i-2\\) 間房子偷或不偷的答案加上第 \\(i\\) 間房子的錢，
- 如果第 \\(i\\) 間房子不偷，那麼答案會從第 \\(i-1\\) 間房子偷或不偷的答案中過來。

時間和空間複雜度都還是 \\(\mathcal{O}(n)\\)，
大家可以自己想一下遞迴的 base case 要怎麼設計，以及如何轉成 `Bottom-Up` 的方式來實作，因為後者在之後會提到如何優化空間複雜度，`Top-Down` 的方式就不會有這個優化的空間複雜度的機會。

## 最長遞增子序列 (Longest Increasing Subsequence, LIS)

>給定一個長度為 \\(n\\) 的整數序列，
>請問這個序列中，最長的遞增子序列長度是多少?
>
> - \\(1 \le n \le 10^3\\)
> - \\(1 \le a_i \le 10^9\\)

這裡要先介紹一個概念，**子序列**，
子序列是指從原始序列中選取一些元素，並保持它們的相對順序，
但不需要連續選取。
例如，對於序列 \\([3, 1, 2, 5]\\)，子序列 \\([3, 2, 5]\\) 是一個合法的子序列，但 \\([3, 5, 2]\\) 不是，因為它們的相對順序被打亂了。

子序列其實就是選跟不選的問題，只是選了誰會變得很重要，會影響到之後的選擇，
這個問題有幾個關鍵的特性：
1. 自己一個元素的子序列長度是 \\(1\\)。
2. 如果 \\(a_i < a_j\\)，那麼 \\(a_i\\) 可以成為 \\(a_j\\) 的前一個元素，
   也就是說 \\(a_j\\) 可以接在 \\(a_i\\) 後面形成一個遞增子序列。
3. 因為求的是子序列，每一個索引值都可能是答案的結尾

我覺得第三點是最為重要的，比起走樓梯問題跟打家劫舍問題，
答案可能會是 \\(f(n)\\) 的值，但這裡需要考慮到所有的索引值。

而第二點其實就在暗示我們轉移方程式的設計，
如果我們要計算第 \\(i\\) 個元素的子序列長度，
我們需要考慮所有 \\(j < i\\) 的元素，
如果 \\(a_j < a_i\\)，那麼我們就可以將 \\(a_j\\) 的子序列長度加上 \\(1\\) 來計算
第 \\(i\\) 個元素的子序列長度。

這裡先看一個例子 ，假設我們有一個序列 \\([1, 6, 7, 2, 5]\\)，
以 \\(5\\) 為例，可以接在 \\(1, 2\\) 後面形成遞增子序列，
因為 \\(1\\) 前面沒有比它小的元素，但是 \\(2\\) 前面有 \\(1\\)，
所以接在 \\(2\\) 後面是比較好的，因為可以形成更長的遞增子序列，
我們可以將 \\(5\\) 的子序列長度設為 \\(3\\)。

根據上面的例子，
我們可以發現每個元素的子序列長度都可以從前面的元素中計算出來，
因此我們可以用一個陣列來記錄每個元素為結尾的最長遞增子序列長度，
設計出以下的轉移方程式：
\\[
f(i) = \max(f(j) + 1) \quad \text{for all } j < i \text{ and } a_j < a_i
\\] 

這裡的 \\(f(i)\\) 代表以第 \\(i\\) 個元素結尾的最長遞增子序列長度，
我們可以用一個陣列來記錄每個元素的最長遞增子序列長度，
因此總共有 \\(n\\) 種狀態，
每個狀態需要知道前面所有的狀態，
因此時間複雜度為 \\(\mathcal{O}(n^2)\\)，
空間複雜度為 \\(\mathcal{O}(n)\\)。

## 前綴和

> 給定一個長度為 \\(n\\) 的整數序列，
> 請問這個序列中，從第 \\(l\\) 個元素到第 \\(r\\) 個元素的和是多少?
> - \\(1 \le n \le 10^5\\)
> - \\(1 \le l \le r \le n\\)
> - \\(1 \le a_i \le 10^9\\)    

我們想要知道任意區間 \\([l, r]\\) 的和，
在這之前，我們可以發現這個和可以由前 \\(r\\) 個元素的和減去前 \\(l-1\\) 個元素的和來計算，而這個前 \\(i\\) 個元素的和可以用一個陣列來記錄，
我們稱為**前綴和 (Prefix Sum)**，
在計算前綴和的時候，我們可以很輕易的得知轉移方程式：
\\[
    f(i) = f(i - 1) + a_i
\\]

這裡的 \\(f(i)\\) 代表前 \\(i\\) 個元素的和，
我們可以用一個陣列來記錄每個元素的前綴和，
因此總共有 \\(n\\) 種狀態，
每個狀態只需要知道前一個狀態的值，
因此時間複雜度為 \\(\mathcal{O}(n)\\)，
空間複雜度為 \\(\mathcal{O}(n)\\)。

在算完前綴和之後，
我們可以很輕易的計算任意區間 \\([l, r]\\) 的和，
只需要 \\(f(r) - f(l - 1)\\)
這樣就可以在 \\(\mathcal{O}(1)\\) 的時間內
計算任意區間的和，
這樣就可以大幅度減少計算時間。

## 0-1 背包問題

0-1 背包問題是動態規劃中經典的問題之一，
它的目的是在給定一個背包的容量和一組物品的重量和價值的情況下，
選擇一些物品放入背包中，
使得背包中的物品總重量不超過背包的容量，
並且物品的總價值最大化。

> 現在有 \\(n\\) 件物品，第 \\(i\\) 件物品的重量為 \\(w_i\\)，價值為 \\(v_i\\)，
> 現在有一個容量為 \\(W\\) 的背包，
> 請問最多能放入多少物品，使得背包中的物品總價值最大化?
>
> - \\(1 \le n \le 10^3\\)
> - \\(1 \le w_i, v_i \le 10^5\\)
> - \\(1 \le W \le 10^5\\)

你仔細觀察後會發現，其實這個問題就是一個子序列問題，
對於每個物品，我們可以選擇放入背包或不放入背包，
但是我們不用像 LIS 或者打家劫舍問題一樣需要考慮前後的關係，
我們只要知道當前剩下多少的容量就可以了，
因此我們可以用一個陣列來記錄每個容量下的最大價值，
設計出以下的轉移方程式：
\\[
f(i, j) = \max(f(i - 1, j), f(i - 1, j - w_i) + v_i)
\\]

這裡的 \\(f(i, j)\\) 代表前 \\(i\\) 件物品在容量為 \\(j\\) 的背包中能取得的最大價值，如果我們想要放入第 \\(i\\) 件物品，
我們需要確保背包的容量 \\(j\\) 能夠容納第 \\(i\\) 件物品的重量 \\(w_i\\)，
因此我們需要考慮兩種情況：
1. 不放入第 \\(i\\) 件物品，這時候最大價值就是前 \\(i-1\\) 件物品在容量為 \\(j\\) 的背包中能取得的最大價值。
2. 放入第 \\(i\\) 件物品，這時候最大價值就是前 \\(i-1\\) 件物品在容量為 \\(j - w_i\\) 的背包中能取得的最大價值加上第 \\(i\\) 件物品的價值 \\(v_i\\)。

我們可以用一個二維陣列來記錄每個物品在每個容量下的最大價值，
因此總共有 \\(n \times W\\) 種狀態，
每個狀態需要知道前一個狀態的值，
因此時間複雜度為 \\(\mathcal{O}(n \times W)\\)，
空間複雜度為 \\(\mathcal{O}(n \times W)\\)。

### 空間優化

我們可以發現，對於每個物品的最大價值，只需要知道前一個物品的最大價值，
在處理第 \\(i\\) 件物品時，只需要知道 \\(f(i - 1, j)\\) 和 \\(f(i - 1, j - w_i)\\) 的值，\\(f(i - 2, j)\\) 以及更早的狀態都不需要了，
我們其實只需要兩個一維陣列來記錄當前物品和前一個物品的最大價值，
因此我們可以將空間複雜度從 \\(\mathcal{O}(n \times W)\\) 降到 \\(\mathcal{O}(W)\\)。

```cpp
vector<int> dp(W + 1, 0); // 初始化 dp 陣列
vector<int> prev(W + 1, -1); // 前一個物品的最大價值
dp[0] = 0; // 當背包容量為 0 時，最大價值為 0
for(int i = 1; i <= n; ++i)
{
    for(int j = w[i]; j <= W; ++j)
        dp[j] = max(prev[j], prev[j - w[i]] + v[i]);
    dp.swap(prev); // 將當前物品的最大價值存到前一個物品的最大價值
}
```

<!-- ## 無限背包問題 -->